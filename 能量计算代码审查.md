# 能量计算代码审查文档

## 能量计算规则
- **用户自己领取空投**：每次 +1 能量
- **首次邀请奖励**：当被邀请人第一次领取空投时，推荐人获得 +2 能量
- **管道收益**：每次被邀请人领取空投时，推荐人获得 +1 能量

## 代码位置

### 1. Indexer 主逻辑 (`src/indexer/indexer.ts`)

```typescript
// 文件：src/indexer/indexer.ts
// 函数：insertClaim (第107-200行)

async function insertClaim(args: {
  txHash: string;
  address: string;
  referrer: string;
  amountWei: string;
  blockNumber: number;
  blockTimeIso: string | null;
}) {
  // 先检查该 tx_hash 是否已经处理过（幂等性检查）
  const { data: existingTx } = await supabase
    .from('claims')
    .select('tx_hash')
    .eq('tx_hash', args.txHash)
    .maybeSingle();
  
  const isNewTx = !existingTx;
  
  // 检查该被邀请人是否已经领取过（用于判断是否需要更新推荐人的 invite_count）
  const { data: existingClaims } = await supabase
    .from('claims')
    .select('tx_hash')
    .eq('address', lower(args.address))
    .limit(1);
  
  const isFirstClaim = !existingClaims || existingClaims.length === 0;

  const { error } = await supabase.from('claims').upsert(
    {
      tx_hash: args.txHash,
      address: args.address,
      referrer: args.referrer,
      amount_wei: args.amountWei,
      block_number: args.blockNumber,
      block_time: args.blockTimeIso,
      status: 'SUCCESS',
      created_at: new Date().toISOString(),
    },
    { onConflict: 'tx_hash' }
  );
  if (error) throw error;

  // ensure user exists (Admin Panel user count)
  await ensureUserRow(args.address, args.referrer);

  // 处理推荐人的能量奖励（仅对新交易处理，保证幂等性）
  const ref = lower(args.referrer);
  if (ref && ref !== '0x0000000000000000000000000000000000000000' && isNewTx) {
    const { data: refData } = await supabase
      .from('users')
      .select('invite_count,energy_total,energy_locked,created_at')
      .eq('address', ref)
      .maybeSingle();
    
    let energyReward = 0;
    let newInviteCount = Number((refData as any)?.invite_count || 0);
    
    // 1. 邀请奖励：如果是第一次领取，奖励 +2 能量
    if (isFirstClaim) {
      newInviteCount += 1;
      energyReward += 2; // ✅ 邀请奖励：从 5 改为 2
    }
    
    // 2. 管道收益：每次下级领取空投，上级获得 +1 能量
    energyReward += 1; // ✅ 管道收益：+1 能量
    
    if (refData) {
      const newEnergyTotal = Number((refData as any)?.energy_total || 0) + energyReward;
      await supabase.from('users').upsert(
        {
          address: ref,
          invite_count: newInviteCount,
          energy_total: newEnergyTotal,
          energy_locked: Number((refData as any)?.energy_locked || 0),
          updated_at: new Date().toISOString(),
          created_at: (refData as any)?.created_at || new Date().toISOString(),
        },
        { onConflict: 'address' }
      );
    } else {
      // 推荐人不存在，创建记录并奖励能量
      await supabase.from('users').upsert(
        {
          address: ref,
          invite_count: newInviteCount > 0 ? newInviteCount : 1,
          energy_total: energyReward,
          energy_locked: 0,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
        { onConflict: 'address' }
      );
    }
  }
}
```

---

### 2. VerifyClaim - 处理已存在交易 (`src/services/verifyClaim.ts`)

```typescript
// 文件：src/services/verifyClaim.ts
// 函数：verifyClaim - 处理已存在交易部分 (第135-230行)

if (existing) {
  // Even if claim exists, still ensure user exists and energy awarded (idempotent).
  await ensureUserRow(address, params.referrer);
  await awardEnergyOnceForTx(address, txHash);
  
  // ✅ 修复：即使交易已存在，也要确保推荐人的 invite_count 和能量奖励正确
  const ref = (params.referrer || '').toLowerCase();
  if (ref && ref !== '0x0000000000000000000000000000000000000000') {
    // 检查该被邀请人是否已经领取过（用于判断是否是首次邀请）
    const { data: existingClaims } = await supabase
      .from('claims')
      .select('tx_hash')
      .eq('address', address)
      .limit(1);
    
    const isFirstClaim = !existingClaims || existingClaims.length === 0;
    
    // 计算实际的邀请数量
    const { data: actualInvites } = await supabase
      .from('claims')
      .select('address')
      .eq('referrer', ref);
    
    const actualInviteCount = actualInvites ? new Set(actualInvites.map((c: any) => c.address.toLowerCase())).size : 0;
    
    // 更新推荐人的 invite_count 和能量（如果不同）
    const { data: refData } = await supabase
      .from('users')
      .select('invite_count,energy_total,energy_locked,created_at')
      .eq('address', ref)
      .maybeSingle();
    
    if (refData) {
      const currentInviteCount = Number((refData as any)?.invite_count || 0);
      const currentEnergy = Number((refData as any)?.energy_total || 0);
      
      // 计算应该有的能量：如果 invite_count 不同，需要重新计算能量
      let newEnergy = currentEnergy;
      if (currentInviteCount !== actualInviteCount) {
        // 重新计算能量：每个首次邀请 +2，每次下级领取 +1
        // 这里我们需要从 claims 表重新计算
        const { data: allInviteeClaims } = await supabase
          .from('claims')
          .select('address,created_at')
          .eq('referrer', ref)
          .order('created_at', { ascending: true });
        
        if (allInviteeClaims) {
          const inviteeSet = new Set<string>();
          let calculatedEnergy = 0;
          
          for (const claim of allInviteeClaims) {
            const inviteeAddr = (claim as any).address.toLowerCase();
            const isFirst = !inviteeSet.has(inviteeAddr);
            
            if (isFirst) {
              inviteeSet.add(inviteeAddr);
              calculatedEnergy += 2; // 首次邀请奖励
            }
            calculatedEnergy += 1; // 管道收益
          }
          
          // 还需要加上用户自己领取空投的能量
          const { data: userClaims } = await supabase
            .from('claims')
            .select('tx_hash')
            .eq('address', ref);
          
          const userClaimCount = userClaims ? userClaims.length : 0;
          calculatedEnergy += userClaimCount; // 用户自己领取的能量
          
          newEnergy = calculatedEnergy;
        }
      }
      
      if (currentInviteCount !== actualInviteCount || currentEnergy !== newEnergy) {
        await supabase.from('users').upsert(
          {
            address: ref,
            invite_count: actualInviteCount,
            energy_total: newEnergy,
            energy_locked: Number((refData as any)?.energy_locked || 0),
            updated_at: new Date().toISOString(),
            created_at: (refData as any)?.created_at || new Date().toISOString(),
          },
          { onConflict: 'address' }
        );
        console.log(`[verifyClaim] ✅ 修复推荐人数据: ${ref}, invite_count: ${currentInviteCount} -> ${actualInviteCount}, energy: ${currentEnergy} -> ${newEnergy}`);
      }
    }
  }
  
  return {
    ok: true,
    txHash,
    amount: ethers.utils.formatEther((existing as any).amount_wei),
    unit: 'RAT',
    blockNumber: Number((existing as any).block_number || 0),
    blockTime: (existing as any).block_time,
    duplicated: true,
  };
}
```

---

### 3. VerifyClaim - 处理新交易 (`src/services/verifyClaim.ts`)

```typescript
// 文件：src/services/verifyClaim.ts
// 函数：verifyClaim - 处理新交易部分 (第353-410行)

// ✅ 处理推荐人的能量奖励（与 Indexer 逻辑一致）
const ref = (params.referrer || '').toLowerCase();
if (ref && ref !== '0x0000000000000000000000000000000000000000') {
  // 检查该被邀请人是否已经领取过
  const { data: existingClaims } = await supabase
    .from('claims')
    .select('tx_hash')
    .eq('address', address)
    .limit(1);
  
  const isFirstClaim = !existingClaims || existingClaims.length === 0;
  
  const { data: refData } = await supabase
    .from('users')
    .select('invite_count,energy_total,energy_locked,created_at')
    .eq('address', ref)
    .maybeSingle();
  
  let energyReward = 0;
  let newInviteCount = Number((refData as any)?.invite_count || 0);
  
  // 1. 邀请奖励：如果是第一次领取，奖励 +2 能量
  if (isFirstClaim) {
    newInviteCount += 1;
    energyReward += 2;
  }
  
  // 2. 管道收益：每次下级领取空投，上级获得 +1 能量
  energyReward += 1;
  
  if (refData) {
    const newEnergyTotal = Number((refData as any)?.energy_total || 0) + energyReward;
    await supabase.from('users').upsert(
      {
        address: ref,
        invite_count: newInviteCount,
        energy_total: newEnergyTotal,
        energy_locked: Number((refData as any)?.energy_locked || 0),
        updated_at: new Date().toISOString(),
        created_at: (refData as any)?.created_at || new Date().toISOString(),
      },
      { onConflict: 'address' }
    );
    console.log(`[verifyClaim] ✅ 更新推荐人能量: ${ref}, +${energyReward} 能量`);
  } else {
    await supabase.from('users').upsert(
      {
        address: ref,
        invite_count: newInviteCount > 0 ? newInviteCount : 1,
        energy_total: energyReward,
        energy_locked: 0,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      { onConflict: 'address' }
    );
    console.log(`[verifyClaim] ✅ 创建推荐人记录: ${ref}, +${energyReward} 能量`);
  }
}
```

---

### 4. Manual Index Transaction (`src/services/indexer.ts`)

```typescript
// 文件：src/services/indexer.ts
// 函数：manualIndexTransaction (第160-260行)

// 处理推荐人的能量奖励
const ref = lower(referrer);
if (ref && ref !== '0x0000000000000000000000000000000000000000') {
  // 检查该被邀请人是否已经领取过
  const { data: existingClaims } = await supabase
    .from('claims')
    .select('tx_hash')
    .eq('address', user)
    .limit(1);
  
  const isFirstClaim = !existingClaims || existingClaims.length === 0;
  
  const { data: refData } = await supabase
    .from('users')
    .select('invite_count,energy_total,energy_locked,created_at')
    .eq('address', ref)
    .maybeSingle();
  
  let energyReward = 0;
  let newInviteCount = Number((refData as any)?.invite_count || 0);
  
  // 1. 邀请奖励：如果是第一次领取，奖励 +2 能量
  if (isFirstClaim) {
    newInviteCount += 1;
    energyReward += 2;
  }
  
  // 2. 管道收益：每次下级领取空投，上级获得 +1 能量
  energyReward += 1;
  
  if (refData) {
    const newEnergyTotal = Number((refData as any)?.energy_total || 0) + energyReward;
    await supabase.from('users').update({
      invite_count: newInviteCount,
      energy_total: newEnergyTotal,
      energy_locked: Number((refData as any)?.energy_locked || 0),
      updated_at: new Date().toISOString(),
    }).eq('address', ref);
    
    console.log(`[manualIndex] ✅ 更新推荐人能量: ${ref}, +${energyReward} 能量`);
  } else {
    await supabase.from('users').upsert(
      {
        address: ref,
        invite_count: newInviteCount > 0 ? newInviteCount : 1,
        energy_total: energyReward,
        energy_locked: 0,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      },
      { onConflict: 'address' }
    );
    console.log(`[manualIndex] ✅ 创建推荐人记录: ${ref}, +${energyReward} 能量`);
  }
}
```

---

### 5. 用户自己领取空投的能量奖励 (`src/services/verifyClaim.ts`)

```typescript
// 文件：src/services/verifyClaim.ts
// 函数：awardEnergyOnceForTx (第107-125行)

async function awardEnergyOnceForTx(address: string, txHash: string) {
  const addr = address.toLowerCase();
  const hash = txHash.toLowerCase();

  // Set claims.energy_awarded=true only once; only then increment energy_total.
  const { data: updated, error: upErr } = await supabase
    .from('claims')
    .update({ energy_awarded: true })
    .eq('tx_hash', hash)
    .eq('address', addr)
    .eq('energy_awarded', false)
    .select('tx_hash')
    .limit(1);
  if (upErr) throw upErr;
  if (!updated || updated.length === 0) return { ok: true, awarded: false };

  await addEnergyOnSuccessfulClaim(addr);
  return { ok: true, awarded: true };
}

async function addEnergyOnSuccessfulClaim(address: string) {
  const addr = address.toLowerCase();
  const { data, error } = await supabase
    .from('users')
    .select('energy_total,energy_locked,created_at')
    .eq('address', addr)
    .maybeSingle();
  if (error) throw error;

  const createdAt = (data as any)?.created_at || new Date().toISOString();
  const energyTotal = Number((data as any)?.energy_total || 0);
  const energyLocked = Number((data as any)?.energy_locked || 0);
  const nextTotal = energyTotal + 1; // 每成功领取一次空投，能量 +1

  const { error: upErr } = await supabase.from('users').upsert(
    { address: addr, energy_total: nextTotal, energy_locked: energyLocked, updated_at: new Date().toISOString(), created_at: createdAt },
    { onConflict: 'address' }
  );
  if (upErr) throw upErr;
}
```

---

## 潜在问题分析

### 问题1：`isFirstClaim` 判断逻辑
在 `verifyClaim` 中，`isFirstClaim` 的判断是在**插入新交易之前**进行的：
```typescript
const { data: existingClaims } = await supabase
  .from('claims')
  .select('tx_hash')
  .eq('address', address)
  .limit(1);

const isFirstClaim = !existingClaims || existingClaims.length === 0;
```
但此时当前交易可能还没有插入到数据库，所以判断可能不准确。

### 问题2：已存在交易的能量重新计算
在处理已存在交易时，能量重新计算的逻辑可能有问题：
- 它只检查 `currentInviteCount !== actualInviteCount` 时才重新计算
- 但如果能量计算错误但 `invite_count` 正确，就不会重新计算

### 问题3：并发问题
如果多个交易同时处理，可能会出现竞态条件，导致能量计算不准确。

---

## 建议的修复方案

1. **统一能量计算逻辑**：创建一个单独的函数来计算能量，所有地方都调用这个函数
2. **修复 `isFirstClaim` 判断**：在插入交易后，或者使用更可靠的判断方式
3. **添加事务保护**：使用数据库事务确保能量计算的原子性
4. **添加日志**：记录每次能量计算的详细信息，便于调试

